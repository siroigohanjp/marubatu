<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ä¸‰ç›®ä¸¦ã¹</title>
<style>
  :root{ --bg:#071022; --panel:#0b1a2a; --accent:#06b6d4; --muted:#94a3b8; --win:#16a34a; }
  body{ margin:0; min-height:100vh; font-family:system-ui, -apple-system, "Hiragino Kaku Gothic ProN","ãƒ¡ã‚¤ãƒªã‚ª",sans-serif; background:linear-gradient(180deg,#071022,#042034); color:#e6eef6; display:flex; align-items:flex-start; justify-content:center; padding:24px; }
  .wrap{ width:1100px; max-width:96vw; display:grid; grid-template-columns:320px 1fr; gap:16px; }
  .card{ background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:10px; padding:12px; border:1px solid rgba(255,255,255,0.03); }
  h2{ margin:6px 0 12px 0; color:var(--accent); font-size:16px; }
  input,button,select{ font-size:14px; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit; }
  button.primary{ background:var(--accent); color:#02121a; border:none; font-weight:700; cursor:pointer; }
  #roomsList{ max-height:300px; overflow:auto; margin-top:8px; display:flex; flex-direction:column; gap:8px; }
  .roomRow{ display:flex; justify-content:space-between; gap:8px; align-items:center; padding:8px; background:rgba(0,0,0,0.12); border-radius:8px; }
  #board{ display:grid; grid-template-columns:repeat(3,120px); gap:8px; justify-content:center; margin-top:12px; }
  .cell{ width:120px; height:120px; display:flex; align-items:center; justify-content:center; font-size:52px; background:rgba(255,255,255,0.02); border-radius:10px; cursor:pointer; user-select:none; }
  .cell.disabled{ opacity:0.5; cursor:not-allowed; }
  #chatLog{ max-height:180px; overflow:auto; background:rgba(0,0,0,0.12); padding:8px; border-radius:8px; margin-top:8px; }
  .chatMsg.self{ text-align:right; color:#bde8ff; margin:4px 0; }
  .chatMsg.other{ text-align:left; color:#ffd99b; margin:4px 0; }
  .small{ font-size:13px; padding:6px 8px; border-radius:8px; }
  #players { display:flex; gap:8px; align-items:center; margin-top:8px; }
  .playerBox{ padding:8px; border-radius:8px; background:rgba(255,255,255,0.02); width:48%; }
  .speaking{ color:#4ade80; font-weight:700; }
  #stats{ margin-top:12px; font-size:13px; color:var(--muted); }
  footer{ margin-top:12px; color:var(--muted); font-size:13px; }
  @media(max-width:980px){ .wrap{ grid-template-columns:1fr; } .cell{ width:90px; height:90px; font-size:40px; } }
</style>
</head>
<body>
<div class="wrap">
  <!-- å·¦ãƒ‘ãƒãƒ«ï¼šãƒ«ãƒ¼ãƒ ä¸€è¦§ãƒ»æ“ä½œ -->
  <div class="card">
    <h2>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š</h2>
    åå‰: <input id="playerName" placeholder="ã‚ãªãŸã®åå‰" /><br/>
    ãƒã‚¤ã‚¯: <button id="toggleMic" class="small">è¨±å¯ / ç„¡åŠ¹</button>
    <div id="micStatus" style="margin-top:6px;color:var(--muted);">ãƒã‚¤ã‚¯: æœªå–å¾—</div>

    <h2 style="margin-top:12px;">ãƒ«ãƒ¼ãƒ </h2>
    <div style="display:flex; gap:8px;">
      <input id="roomIdInput" placeholder="éƒ¨å±‹ã‚³ãƒ¼ãƒ‰(ç©ºã§è‡ªå‹•ç”Ÿæˆ)" />
      <button id="createRoomBtn" class="small">ä½œæˆ</button>
    </div>
    <div style="display:flex; gap:8px; margin-top:8px;">
      <button id="joinBtn" class="primary">å‚åŠ  / è‡ªå‹•ãƒãƒƒãƒ</button>
      <button id="leaveBtn" class="small">é€€å‡º</button>
    </div>

    <h3 style="margin-top:12px;">å…¬é–‹ãƒ«ãƒ¼ãƒ ä¸€è¦§</h3>
    <div id="roomsList"></div>
    <button id="refreshRooms" class="small" style="margin-top:8px;">æ›´æ–°</button>

    <h3 style="margin-top:12px;">è‡ªåˆ†ã®æˆ¦ç¸¾</h3>
    <div id="stats">Wins:0 / Losses:0 / Draws:0</div>

    <footer>
      Firebase Realtime DB ã‚’ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°ã¨çŠ¶æ…‹ä¿å­˜ã«ä½¿ç”¨ã—ã¾ã™ã€‚<br/>
      éŸ³å£°ã¯ãƒ–ãƒ©ã‚¦ã‚¶é–“ã®WebRTCã§ç›´æ¥é€å—ä¿¡ã—ã¾ã™ã€‚å…¬é–‹æ™‚ã¯ wss + TURN æ¤œè¨ã‚’ã€‚
    </footer>
  </div>

  <!-- å³ãƒ‘ãƒãƒ«ï¼šã‚²ãƒ¼ãƒ ãƒ»ãƒãƒ£ãƒƒãƒˆ -->
  <div class="card">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <h2>ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ä¸‰ç›®ä¸¦ã¹</h2>
      <div id="connStatus" style="color:var(--muted)">çŠ¶æ…‹: æœªæ¥ç¶š</div>
    </div>

    <div id="players">
      <div class="playerBox">
        <div>ã‚ãªãŸ: <span id="myName">-</span> (<span id="myMark">-</span>) <span id="mySpeaking" style="float:right"></span></div>
        <div id="myAudioMeter" style="height:6px;background:#051827;border-radius:4px;margin-top:6px;"></div>
      </div>
      <div class="playerBox">
        <div>ç›¸æ‰‹: <span id="opName">-</span> (<span id="opMark">-</span>) <span id="opSpeaking" style="float:right"></span></div>
        <div id="opAudioMeter" style="height:6px;background:#051827;border-radius:4px;margin-top:6px;"></div>
      </div>
    </div>

    <div id="board"></div>

    <div style="display:flex; justify-content:space-between; align-items:center; margin-top:8px;">
      <div>ã‚¿ãƒ¼ãƒ³: <span id="turnInfo">-</span></div>
      <div>çµæœ: <span id="result">-</span></div>
      <div><button id="resetBtn" class="small">ãƒªã‚»ãƒƒãƒˆ</button></div>
    </div>

    <h3 style="margin-top:12px;">ãƒãƒ£ãƒƒãƒˆ</h3>
    <div id="chatLog"></div>
    <div style="display:flex; gap:8px; margin-top:8px;">
      <input id="chatInput" placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸" style="flex:1;" />
      <button id="sendChat" class="small">é€ä¿¡</button>
    </div>
  </div>
</div>

<!-- Firebase SDK (compat 11) -->
<script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-database-compat.js"></script>

<script>
/* ================================================================
  ä½¿ã„æ–¹ï¼š
  1) ä¸‹ã® firebaseConfig ã‚’ã‚ãªãŸã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±ã«ç½®ãæ›ãˆã¦ãã ã•ã„ã€‚
  2) Realtime Database ã®ãƒ«ãƒ¼ãƒ«ã¯ãƒ†ã‚¹ãƒˆæ™‚ã¯å…¨é–‹ã§ã‚‚OKï¼ˆå¾Œè¿°ï¼‰ã€‚
  3) GitHub Pages ã«ç½®ã„ã¦å‹•ã‹ã›ã¾ã™ï¼ˆwss,tlsã¯å…¬é–‹æ™‚ã«è¦æ¤œè¨ï¼‰ã€‚
================================================================ */

const firebaseConfig = {
  apiKey: "AIzaSyDNGhUEQXD0HQ-WDxehJojpJUWd1xzkb8g",
  authDomain: "siroigohan-marubatu.firebaseapp.com",
  projectId: "siroigohan-marubatu",
  storageBucket: "siroigohan-marubatu.firebasestorage.app",
  messagingSenderId: "188742628397",
  appId: "1:188742628397:web:06ab4a88ae588b7be774a4",
  measurementId: "G-KZ4B04DY6H"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ------------------- çŠ¶æ…‹å¤‰æ•° ------------------- */
let pc = null;
let localStream = null;
let remoteStream = null;
let dc = null;
let roomRef = null;
let roomId = null;
let playerId = null;
let isHost = false;
let myMark='-';
let opMark='-';
let myName = '';
let opName = '';
let boardState = Array(9).fill(null);
let myTurn = false;
let stats = {wins:0,losses:0,draws:0};

/* ------------------- UI refs ------------------- */
const roomsListEl = document.getElementById('roomsList');
const roomIdInput = document.getElementById('roomIdInput');
const createRoomBtn = document.getElementById('createRoomBtn');
const joinBtn = document.getElementById('joinBtn');
const leaveBtn = document.getElementById('leaveBtn');
const refreshRooms = document.getElementById('refreshRooms');
const playerNameEl = document.getElementById('playerName');
const micBtn = document.getElementById('toggleMic');
const micStatus = document.getElementById('micStatus');
const statsEl = document.getElementById('stats');

const connStatus = document.getElementById('connStatus');
const myNameEl = document.getElementById('myName');
const opNameEl = document.getElementById('opName');
const myMarkEl = document.getElementById('myMark');
const opMarkEl = document.getElementById('opMark');
const mySpeaking = document.getElementById('mySpeaking');
const opSpeaking = document.getElementById('opSpeaking');
const myAudioMeter = document.getElementById('myAudioMeter');
const opAudioMeter = document.getElementById('opAudioMeter');

const boardEl = document.getElementById('board');
const turnInfo = document.getElementById('turnInfo');
const resultEl = document.getElementById('result');
const resetBtn = document.getElementById('resetBtn');

const chatLog = document.getElementById('chatLog');
const chatInput = document.getElementById('chatInput');
const sendChatBtn = document.getElementById('sendChat');

/* ------------------- åˆæœŸæç”»ï¼šç›¤é¢ ------------------- */
function initBoardUI(){
  boardEl.innerHTML='';
  for(let i=0;i<9;i++){
    const c = document.createElement('div');
    c.className='cell';
    c.dataset.i=i;
    c.onclick = ()=> onCellClick(i);
    boardEl.appendChild(c);
  }
  renderBoard();
}
initBoardUI();

function renderBoard(){
  for(let i=0;i<9;i++){
    const c = boardEl.children[i];
    c.textContent = boardState[i]||'';
    c.classList.toggle('disabled', !myTurn || !!boardState[i]);
  }
  turnInfo.textContent = myTurn ? 'ã‚ãªãŸã®æ‰‹ç•ª': 'ç›¸æ‰‹ã®æ‰‹ç•ª';
}

/* ------------------- Firebase: ãƒ«ãƒ¼ãƒ ä¸€è¦§å–å¾— & è‡ªå‹•ãƒãƒƒãƒ ------------------- */
async function fetchRooms(){
  roomsListEl.innerHTML = '<div style="color:var(--muted)">å–å¾—ä¸­â€¦</div>';
  const snap = await db.ref('rooms').orderByChild('createdAt').once('value');
  const data = snap.val() || {};
  roomsListEl.innerHTML = '';
  const rows = Object.entries(data).sort((a,b)=> (b[1].playersCount||0)-(a[1].playersCount||0));
  if(rows.length===0) roomsListEl.innerHTML = '<div style="color:var(--muted)">åˆ©ç”¨å¯èƒ½ãªãƒ«ãƒ¼ãƒ ãŒã‚ã‚Šã¾ã›ã‚“</div>';
  rows.forEach(([id, info])=>{
    const row = document.createElement('div');
    row.className='roomRow';
    row.innerHTML = `<div><strong>${id}</strong><div style="font-size:12px;color:var(--muted)">players: ${info.playersCount||0}</div></div>`;
    const btn = document.createElement('button');
    btn.className='small';
    btn.textContent = (info.playersCount||0) < 2 ? 'å‚åŠ ' : 'æº€å“¡';
    btn.disabled = (info.playersCount||0) >= 2;
    btn.onclick = ()=> { roomIdInput.value = id; joinToRoom(id); };
    row.appendChild(btn);
    roomsListEl.appendChild(row);
  });
}

refreshRooms.onclick = fetchRooms;
fetchRooms();

/* è‡ªå‹•ãƒãƒƒãƒ: ç©ºããƒ«ãƒ¼ãƒ ãŒã‚ã‚Œã°å‚åŠ ã€ãªã‘ã‚Œã°ä½œæˆ */
async function autoMatch(){
  const snap = await db.ref('rooms').once('value');
  const rooms = snap.val() || {};
  for(const id of Object.keys(rooms)){
    if((rooms[id].playersCount||0) < 2){
      return id; // ç©ºããŒè¦‹ã¤ã‹ã£ãŸ
    }
  }
  // è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆ
  return 'room-' + Math.random().toString(36).slice(2,8);
}

/* ------------------- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åãƒ»ID ------------------- */
function ensurePlayer(){
  playerId = playerId || Math.random().toString(36).slice(2,9);
  myName = (playerNameEl.value || 'Player-' + playerId.slice(0,4)).trim();
  myNameEl.textContent = myName;
  // load stats
  loadStats();
}

playerNameEl.addEventListener('change', ()=>{ ensurePlayer(); saveStatsToUI(); });

/* ------------------- ãƒã‚¤ã‚¯å–å¾—ãƒ»éŸ³å£°é–¢é€£ ------------------- */
let localAnalyser = null;
let remoteAnalyser = null;
let localMeterInterval = null;
let opAudioEl = null;

micBtn.onclick = async ()=>{
  if(localStream){
    // stop
    stopLocalAudio();
    return;
  }
  try{
    localStream = await navigator.mediaDevices.getUserMedia({ audio:true });
    micStatus.textContent = 'ãƒã‚¤ã‚¯: æ¥ç¶šä¸­';
    micBtn.textContent = 'ãƒã‚¤ã‚¯åœæ­¢';
    attachLocalStreamToPC();
    setupLocalMeter();
  }catch(e){
    console.error(e);
    micStatus.textContent = 'ãƒã‚¤ã‚¯å–å¾—å¤±æ•—';
    alert('ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®æ¨©é™ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
  }
};

function stopLocalAudio(){
  if(localStream){
    localStream.getTracks().forEach(t=>t.stop());
    localStream = null;
    micStatus.textContent = 'ãƒã‚¤ã‚¯: åœæ­¢';
    micBtn.textContent = 'è¨±å¯ / ç„¡åŠ¹';
    if(localAnalyser){ localAnalyser.disconnect(); localAnalyser = null; }
    clearInterval(localMeterInterval);
    if(myAudioMeter) myAudioMeter.style.width = '0%';
  }
}

/* attach local audio tracks to peer connection if exists */
function attachLocalStreamToPC(){
  if(!pc || !localStream) return;
  localStream.getAudioTracks().forEach(track=>{
    pc.addTrack(track, localStream);
  });
  // create analyser for local meter
  try{
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const src = audioCtx.createMediaStreamSource(localStream);
    localAnalyser = audioCtx.createAnalyser();
    localAnalyser.fftSize = 256;
    src.connect(localAnalyser);
    localMeterInterval = setInterval(()=> {
      const arr = new Uint8Array(localAnalyser.frequencyBinCount);
      localAnalyser.getByteFrequencyData(arr);
      const sum = arr.reduce((a,b)=>a+b,0);
      const avg = sum / arr.length;
      const pct = Math.min(100, Math.round((avg/128)*100));
      myAudioMeter.style.width = pct + '%';
      mySpeaking.textContent = pct > 10 ? 'ğŸŸ¢' : '';
      mySpeaking.className = pct > 10 ? 'speaking' : '';
    }, 150);
  }catch(e){ console.warn('local meter err', e); }
}

/* ------------------- PeerConnection & Signaling (Firebase Realtime DB) ------------------- */
async function preparePeerConnection(){
  pc = new RTCPeerConnection({ iceServers:[ { urls:'stun:stun.l.google.com:19302' } ] });

  // add local stream tracks (if mic already allowed)
  if(localStream){
    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
  }

  // DataChannel (if host we'll create; if joiner we'll get ondatachannel)
  pc.ondatachannel = (ev)=> {
    dc = ev.channel;
    setupDataChannel();
  };

  // remote tracks (audio)
  remoteStream = new MediaStream();
  pc.ontrack = (ev)=> {
    ev.streams.forEach(s=> s.getAudioTracks().forEach(t => remoteStream.addTrack(t)));
    // attach to an audio element
    ensureRemoteAudioEl();
    opAudioEl.srcObject = remoteStream;
    opAudioEl.play().catch(()=>{});
    setupRemoteMeter();
  };

  pc.onicecandidate = (e)=> {
    if(!e.candidate) return;
    roomRef.child(isHost ? 'offerCandidates' : 'answerCandidates').push(e.candidate.toJSON());
  };

  pc.onconnectionstatechange = ()=>{
    connStatus.textContent = 'çŠ¶æ…‹: ' + pc.connectionState;
    if(pc.connectionState === 'connected'){
      console.log('connected');
    }
    if(pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed'){
      // cleanup handled elsewhere
    }
  };

  // if we are host, create DC
  if(isHost){
    dc = pc.createDataChannel('game');
    setupDataChannel();
  }
}

/* DataChannel ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç† */
function setupDataChannel(){
  if(!dc) return;
  dc.onopen = ()=> {
    console.log('DC open');
    connStatus.textContent = 'çŠ¶æ…‹: DataChannel open';
    // send identity
    sendDC({ type:'identity', name: myName, id: playerId });
  };
  dc.onmessage = (ev) => {
    const data = safeJSON(ev.data);
    if(!data) return;
    handleAppMessage(data);
  };
}

/* å®‰å…¨ã« JSON parse */
function safeJSON(s){
  try{ return JSON.parse(s); }catch(e){ return null; }
}

/* send via DataChannel if ready */
function sendDC(obj){
  if(dc && dc.readyState === 'open'){ dc.send(JSON.stringify(obj)); }
}

/* Firebase ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°: ãƒ«ãƒ¼ãƒ ä½œæˆ */
async function createRoomManual(id){
  ensurePlayer();
  roomId = id || ('room-' + Math.random().toString(36).slice(2,8));
  isHost = true;
  roomRef = db.ref('rooms/' + roomId);
  // create room entry
  await roomRef.set({ createdAt: Date.now(), playersCount:1, players: { [playerId]: { name: myName }} });
  roomRef.child('playersCount').on('value', ()=>{}); // keep path alive
  await preparePeerConnection();

  // offer
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  await roomRef.update({ offer: offer });

  // listen for answer
  roomRef.child('answer').on('value', async snap=> {
    const val = snap.val();
    if(val && !pc.currentRemoteDescription){
      await pc.setRemoteDescription(new RTCSessionDescription(val));
      connStatus.textContent = 'çŠ¶æ…‹: ãƒªãƒ¢ãƒ¼ãƒˆ answer å—ä¿¡';
    }
  });

  // listen for answerCandidates
  roomRef.child('answerCandidates').on('child_added', async snap=>{
    const cand = snap.val();
    try{ await pc.addIceCandidate(new RTCIceCandidate(cand)); }catch(e){ console.warn(e); }
  });

  // listen for players (to update UI)
  roomRef.child('players').on('value', snap => {
    const players = snap.val() || {};
    updatePlayersUI(players);
  });

  // listen for chat persisted in DB (optional)
  roomRef.child('chat').on('child_added', snap => {
    const msg = snap.val();
    appendChat(msg.name, msg.text, msg.id === playerId ? 'self' : 'other');
  });

  // listen for offerCandidates (in case later)
  roomRef.child('offerCandidates').on('child_added', snap => {
    // we don't need them as host; included for completeness
  });

  updateRoomListCount(1);
  myNameEl.textContent = myName;
  document.getElementById('connStatus').textContent = 'ãƒ«ãƒ¼ãƒ ä½œæˆ: ' + roomId;
  await waitForDCOpenAndInitGame();
}

/* join room flow */
async function joinToRoom(id){
  ensurePlayer();
  roomId = id;
  roomRef = db.ref('rooms/' + roomId);
  const snap = await roomRef.once('value');
  if(!snap.exists()){
    alert('æŒ‡å®šã—ãŸãƒ«ãƒ¼ãƒ ã¯å­˜åœ¨ã—ã¾ã›ã‚“');
    return;
  }
  // join: increment playersCount and write player record
  await roomRef.child('players/' + playerId).set({ name: myName });
  await roomRef.child('playersCount').transaction(c => (c||0) + 1);

  isHost = false;
  await preparePeerConnection();

  // get offer and setRemote
  const offerSnap = await roomRef.child('offer').once('value');
  const offer = offerSnap.val();
  if(!offer){ alert('Offer ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; }
  await pc.setRemoteDescription(new RTCSessionDescription(offer));
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  await roomRef.update({ answer: answer });

  // push answer candidates
  roomRef.child('offerCandidates').on('child_added', async snap=>{
    const cand = snap.val();
    try{ await pc.addIceCandidate(new RTCIceCandidate(cand)); }catch(e){ console.warn(e); }
  });

  // send any local ICE candidate (handled in onicecandidate)
  roomRef.child('answerCandidates').on('child_added', snap => { /* host will add this */ });

  // players observer
  roomRef.child('players').on('value', snap => {
    const players = snap.val() || {};
    updatePlayersUI(players);
  });

  // chat observer stored in DB
  roomRef.child('chat').on('child_added', snap => {
    const msg = snap.val();
    appendChat(msg.name, msg.text, msg.id === playerId ? 'self' : 'other');
  });

  myNameEl.textContent = myName;
  document.getElementById('connStatus').textContent = 'ãƒ«ãƒ¼ãƒ å‚åŠ : ' + roomId;
  await waitForDCOpenAndInitGame();
}

/* wait for DataChannel open and assign marks */
function waitForDCOpenAndInitGame(){
  return new Promise((resolve) => {
    const to = setInterval(()=>{
      if(dc && dc.readyState === 'open'){
        clearInterval(to);
        // send identity to peer, they'll respond with their identity as well
        sendDC({ type:'identity', name: myName, id: playerId });
        // assign marks: host X first
        if(isHost){ myMark='X'; opMark='O'; myTurn=true; sendDC({ type:'assign', mark:'O', first:false }); }
        else { myMark='O'; opMark='X'; myTurn=false; }
        myMarkEl.textContent = myMark;
        opMarkEl.textContent = opMark;
        renderBoard();
        resolve();
      }
    }, 200);
    // timeout fallback
    setTimeout(()=>{ clearInterval(to); resolve(); }, 10000);
  });
}

/* ------------------- DataChannel ã‚¢ãƒ—ãƒªå±¤ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ ------------------- */
function handleAppMessage(data){
  switch(data.type){
    case 'identity':
      opName = data.name || 'ç›¸æ‰‹';
      opNameEl.textContent = opName;
      break;
    case 'assign':
      opMark = data.mark;
      myMark = (data.mark === 'X') ? 'O' : 'X';
      myMarkEl.textContent = myMark;
      opMarkEl.textContent = opMark;
      myTurn = !!data.first;
      renderBoard();
      break;
    case 'move':
      boardState[data.pos] = data.mark;
      myTurn = (data.mark !== myMark); // opponent moved => my turn if I haven't won
      renderBoard();
      checkGameEndAndNotify();
      break;
    case 'chat':
      appendChat(data.name || 'ç›¸æ‰‹', data.text, data.id === playerId ? 'self' : 'other');
      // persist chat to DB
      if(roomRef) roomRef.child('chat').push({ id: data.id, name: data.name, text: data.text, ts: Date.now() });
      break;
    case 'gameover':
      handleGameOver(data.winner);
      break;
    case 'reset':
      resetBoardLocal();
      break;
    default:
      console.log('unknown app msg', data);
  }
}

/* ------------------- ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯: ã‚¯ãƒªãƒƒã‚¯ã§é€ä¿¡ ------------------- */
function onCellClick(i){
  if(!dc || dc.readyState !== 'open'){ alert('ã¾ã æ¥ç¶šã•ã‚Œã¦ã„ã¾ã›ã‚“'); return; }
  if(!myTurn || boardState[i]) return;
  boardState[i] = myMark;
  renderBoard();
  sendDC({ type:'move', pos: i, mark: myMark });
  myTurn = false;
  checkGameEndAndNotify();
}

/* check game end locally and inform opponent and record results */
function checkGameEndAndNotify(){
  const winner = calcWinner(boardState);
  if(winner){
    sendDC({ type:'gameover', winner });
    handleGameOver(winner);
  } else if(boardState.every(Boolean)){
    sendDC({ type:'gameover', winner: 'draw' });
    handleGameOver('draw');
  }
}

/* calc winner */
function calcWinner(b){
  const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
  for(const [a,b1,c] of lines){
    if(b[a] && b[a] === b[b1] && b[a] === b[c]) return b[a];
  }
  return null;
}

/* handle gameover: update UI and save stats */
async function handleGameOver(winner){
  if(winner === 'draw'){
    resultEl.textContent = 'å¼•ãåˆ†ã‘';
    await saveStats('draw');
  } else if(winner === myMark){
    resultEl.textContent = 'ã‚ãªãŸã®å‹ã¡';
    await saveStats('win');
  } else {
    resultEl.textContent = 'ç›¸æ‰‹ã®å‹ã¡';
    await saveStats('loss');
  }
}

/* reset board (local and send) */
resetBtn.onclick = ()=>{
  resetBoardLocal();
  if(dc && dc.readyState === 'open') sendDC({ type:'reset' });
};
function resetBoardLocal(){
  boardState = Array(9).fill(null);
  resultEl.textContent = '';
  myTurn = isHost; // host gets first
  renderBoard();
}

/* ------------------- ãƒãƒ£ãƒƒãƒˆUI ------------------- */
function appendChat(name, text, cls='other'){
  const d = document.createElement('div');
  d.className = 'chatMsg ' + cls;
  d.textContent = name + ': ' + text;
  chatLog.appendChild(d);
  chatLog.scrollTop = chatLog.scrollHeight;
}
sendChatBtn.onclick = ()=>{
  const text = chatInput.value.trim();
  if(!text) return;
  appendChat(myName, text, 'self');
  // send via DC and persist in DB
  sendDC({ type:'chat', name: myName, id: playerId, text });
  if(roomRef) roomRef.child('chat').push({ id: playerId, name: myName, text, ts: Date.now() });
  chatInput.value = '';
};

/* ------------------- players UI update ------------------- */
function updatePlayersUI(players){
  const ids = Object.keys(players || {});
  let otherId = ids.find(id => id !== playerId);
  myNameEl.textContent = myName;
  if(otherId){
    opName = players[otherId].name || 'ç›¸æ‰‹';
    opNameEl.textContent = opName;
  } else {
    opNameEl.textContent = '-';
  }
}

/* ------------------- Audio: remote analyser & meter ------------------- */
function ensureRemoteAudioEl(){
  if(opAudioEl) return;
  opAudioEl = document.createElement('audio');
  opAudioEl.autoplay = true;
  opAudioEl.muted = false;
  opAudioEl.style.display = 'none';
  document.body.appendChild(opAudioEl);
}

let remoteAudioCtx = null;
function setupRemoteMeter(){
  try{
    if(!opAudioEl || !opAudioEl.srcObject) return;
    remoteAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const src = remoteAudioCtx.createMediaStreamSource(opAudioEl.srcObject);
    remoteAnalyser = remoteAudioCtx.createAnalyser();
    remoteAnalyser.fftSize = 256;
    src.connect(remoteAnalyser);
    // periodic meter
    setInterval(()=>{
      if(!remoteAnalyser) return;
      const arr = new Uint8Array(remoteAnalyser.frequencyBinCount);
      remoteAnalyser.getByteFrequencyData(arr);
      const sum = arr.reduce((a,b)=>a+b,0);
      const avg = sum / arr.length;
      const pct = Math.min(100, Math.round((avg/128)*100));
      opAudioMeter.style.width = pct + '%';
      opSpeaking.textContent = pct > 10 ? 'ğŸŸ¢' : '';
      opSpeaking.className = pct > 10 ? 'speaking' : '';
    }, 180);
  }catch(e){ console.warn('remote meter err', e); }
}

/* ------------------- Stats ä¿å­˜/èª­ã¿è¾¼ã¿ ------------------- */
async function loadStats(){
  ensurePlayer();
  const snap = await db.ref('stats/' + myName).once('value');
  const val = snap.val();
  if(val){
    stats = val;
  } else {
    stats = { wins:0, losses:0, draws:0 };
  }
  saveStatsToUI();
}

function saveStatsToUI(){
  statsEl.textContent = `Wins:${stats.wins} / Losses:${stats.losses} / Draws:${stats.draws}`;
}

/* update stats by outcome and persist */
async function saveStats(outcome){
  ensurePlayer();
  if(outcome === 'win') stats.wins = (stats.wins||0) + 1;
  else if(outcome === 'loss') stats.losses = (stats.losses||0) + 1;
  else stats.draws = (stats.draws||0) + 1;
  await db.ref('stats/' + myName).set(stats);
  saveStatsToUI();
}

/* ------------------- é€€å‡º & ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ— ------------------- */
leaveBtn.onclick = async ()=>{
  if(!roomRef) return;
  try{
    // remove player entry and decrement count
    await roomRef.child('players/' + playerId).remove();
    await roomRef.child('playersCount').transaction(c => Math.max(0, (c||1) - 1));
    // if hosts leaving, you might want to remove room if empty
    const snap = await roomRef.once('value');
    const val = snap.val() || {};
    if(!val.players || Object.keys(val.players).length === 0){
      await roomRef.remove();
    }
  }catch(e){ console.warn(e); }
  cleanupAll();
  fetchRooms();
};

/* cleanup local objects */
function cleanupAll(){
  if(dc){ try{ dc.close(); }catch(e){} dc = null; }
  if(pc){ try{ pc.close(); }catch(e){} pc = null; }
  if(roomRef){ try{ roomRef.off(); }catch(e){} roomRef = null; }
  if(localStream){ localStream.getTracks().forEach(t=>t.stop()); localStream = null; }
  if(opAudioEl){ opAudioEl.srcObject = null; try{ opAudioEl.remove(); }catch(e){} opAudioEl=null; }
  myMark = opMark = '-';
  myMarkEl.textContent = myMark; opMarkEl.textContent = opMark;
  myNameEl.textContent = myName; opNameEl.textContent = '-';
  boardState = Array(9).fill(null);
  myTurn = false;
  renderBoard();
  connStatus.textContent = 'çŠ¶æ…‹: åˆ‡æ–­';
}

/* ------------------- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£: ãƒ«ãƒ¼ãƒ ä½œæˆ/å‚åŠ ã®UIãƒœã‚¿ãƒ³ ------------------- */
createRoomBtn.onclick = async ()=> {
  ensurePlayer();
  const id = roomIdInput.value.trim() || ('room-' + Math.random().toString(36).slice(2,7));
  await createRoomManual(id);
  fetchRooms();
};

joinBtn.onclick = async ()=> {
  ensurePlayer();
  // if specific id provided -> join; otherwise auto-match
  let id = roomIdInput.value.trim();
  if(!id){
    id = await autoMatch();
    roomIdInput.value = id;
  }
  await joinToRoom(id);
  fetchRooms();
};

/* ------------------- èµ·å‹•æ™‚: ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ID ã¨ åå‰åˆæœŸåŒ– ------------------- */
(function boot(){
  playerId = localStorage.getItem('webrtc_playerId');
  if(!playerId){ playerId = Math.random().toString(36).slice(2,9); localStorage.setItem('webrtc_playerId', playerId); }
  const storedName = localStorage.getItem('webrtc_playerName') || '';
  playerNameEl.value = storedName;
  ensurePlayer();
  playerNameEl.addEventListener('change', ()=>{ localStorage.setItem('webrtc_playerName', playerNameEl.value); ensurePlayer(); });
})();

</script>
</body>
</html>
