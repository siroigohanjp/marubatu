<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ä¸‰ç›®ä¸¦ã¹</title>
<style>
:root{--bg:#071022;--panel:#0b1a2a;--accent:#06b6d4;--muted:#94a3b8;--win:#16a34a}
body{margin:0;min-height:100vh;font-family:system-ui,-apple-system,"Hiragino Kaku Gothic ProN","ãƒ¡ã‚¤ãƒªã‚ª",sans-serif;background:linear-gradient(180deg,var(--bg),#042034);color:#e6eef6;padding:18px;display:flex;justify-content:center}
.wrap{width:1100px;max-width:96vw;display:grid;grid-template-columns:320px 1fr;gap:16px}
.card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:10px;padding:12px;border:1px solid rgba(255,255,255,0.03)}
h2{color:var(--accent);margin:6px 0 12px 0;font-size:16px}
input,button,select{font-size:14px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
button.primary{background:var(--accent);color:#02121a;border:none;font-weight:700;cursor:pointer}
#roomsList{max-height:260px;overflow:auto;margin-top:8px;display:flex;flex-direction:column;gap:8px}
.roomRow{display:flex;justify-content:space-between;gap:8px;align-items:center;padding:8px;background:rgba(0,0,0,0.12);border-radius:8px}
#board{display:grid;grid-template-columns:repeat(3,120px);gap:8px;justify-content:center;margin-top:12px}
.cell{width:120px;height:120px;display:flex;align-items:center;justify-content:center;font-size:52px;background:rgba(255,255,255,0.02);border-radius:10px;user-select:none;cursor:pointer}
.cell.disabled{opacity:0.5;cursor:not-allowed}
#chatLog{max-height:180px;overflow:auto;background:rgba(0,0,0,0.12);padding:8px;border-radius:8px;margin-top:8px}
.chatMsg.self{text-align:right;color:#bde8ff;margin:4px 0}
.chatMsg.other{text-align:left;color:#ffd99b;margin:4px 0}
.playerBox{padding:8px;border-radius:8px;background:rgba(255,255,255,0.02)}
.speaking{color:#4ade80;font-weight:700}
.meter{height:8px;background:#051827;border-radius:4px;margin-top:6px;width:100%}
.small{font-size:13px;padding:6px 8px;border-radius:8px}
footer{margin-top:12px;color:var(--muted);font-size:13px}
@media(max-width:980px){.wrap{grid-template-columns:1fr}.cell{width:90px;height:90px;font-size:40px}}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h2>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š</h2>
    <div>åå‰: <input id="playerName" placeholder="ã‚ãªãŸã®åå‰" style="width:100%"></div>
    <div style="margin-top:8px">
      <button id="micToggle" class="small">ãƒã‚¤ã‚¯è¨±å¯ / åœæ­¢</button>
      <div id="micStatus" style="margin-top:6px;color:var(--muted)">ãƒã‚¤ã‚¯: æœªæ¥ç¶š</div>
    </div>

    <h2 style="margin-top:12px">ãƒ«ãƒ¼ãƒ </h2>
    <div style="display:flex;gap:8px">
      <input id="roomIdInput" placeholder="éƒ¨å±‹ã‚³ãƒ¼ãƒ‰(ç©ºã§è‡ªå‹•ç”Ÿæˆ)" style="flex:1"/>
      <button id="createRoomBtn" class="small">ä½œæˆ</button>
    </div>
    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="joinBtn" class="primary">å‚åŠ  / è‡ªå‹•ãƒãƒƒãƒ</button>
      <button id="leaveBtn" class="small">é€€å‡º</button>
    </div>

    <h3 style="margin-top:12px">å…¬é–‹ãƒ«ãƒ¼ãƒ ä¸€è¦§</h3>
    <div id="roomsList"></div>
    <button id="refreshRooms" class="small" style="margin-top:8px">æ›´æ–°</button>

    <h3 style="margin-top:12px">ã‚ãªãŸã®æˆ¦ç¸¾</h3>
    <div id="stats">Wins:0 / Losses:0 / Draws:0</div>

    <footer>
      ï½–0.0.1
    </footer>
  </div>

  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <h2>ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ä¸‰ç›®ä¸¦ã¹</h2>
      <div id="connStatus" style="color:var(--muted)">çŠ¶æ…‹: åˆ‡æ–­</div>
    </div>

    <div style="display:flex;gap:8px;margin-top:8px">
      <div class="playerBox" style="flex:1">
        ã‚ãªãŸ: <span id="myName">-</span> (<span id="myMark">-</span>) <span id="mySpeaking" style="float:right"></span>
        <div class="meter"><div id="myMeter" style="height:8px;width:0%;background:linear-gradient(90deg,#06b6d4,#38bdf8);border-radius:4px"></div></div>
      </div>
      <div class="playerBox" style="flex:1">
        ç›¸æ‰‹: <span id="opName">-</span> (<span id="opMark">-</span>) <span id="opSpeaking" style="float:right"></span>
        <div class="meter"><div id="opMeter" style="height:8px;width:0%;background:linear-gradient(90deg,#facc15,#f97316);border-radius:4px"></div></div>
      </div>
    </div>

    <div id="board"></div>

    <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px">
      <div>ã‚¿ãƒ¼ãƒ³: <span id="turnInfo">-</span></div>
      <div>çµæœ: <span id="result">-</span></div>
      <div><button id="resetBtn" class="small">ãƒªã‚»ãƒƒãƒˆ</button></div>
    </div>

    <h3 style="margin-top:12px">ãƒãƒ£ãƒƒãƒˆ</h3>
    <div id="chatLog"></div>
    <div style="display:flex;gap:8px;margin-top:8px">
      <input id="chatInput" placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸" style="flex:1">
      <button id="sendChat" class="small">é€ä¿¡</button>
    </div>
  </div>
</div>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-database-compat.js"></script>

<script>
/* =========================
  å¿…ãšã“ã“ã‚’ã‚ãªãŸã® Firebase è¨­å®šã«æ›¸ãæ›ãˆã¦ãã ã•ã„
  (Firebase ã‚³ãƒ³ã‚½ãƒ¼ãƒ« â†’ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®š â†’ ã‚¦ã‚§ãƒ–ã‚¢ãƒ—ãƒª)
========================= */
  const firebaseConfig = {
    apiKey: "AIzaSyAI3pNSCaU2teHdqa1Rh1eLoQu1VZYtoh4",
    authDomain: "webrtc-gamesg.firebaseapp.com",
    databaseURL: "https://webrtc-gamesg-default-rtdb.firebaseio.com",
    projectId: "webrtc-gamesg",
    storageBucket: "webrtc-gamesg.firebasestorage.app",
    messagingSenderId: "214608437119",
    appId: "1:214608437119:web:369a938ed095dded62c44a"
  };
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ---------------- state ---------------- */
let pc = null;
let dc = null;
let localStream = null;
let remoteStream = null;
let playerId = null;
let playerName = null;
let roomId = null;
let roomRef = null;
let isHost = false;
let boardState = Array(9).fill(null);
let myMark = '-', opMark = '-';
let myTurn = false;
let stats = {wins:0,losses:0,draws:0};
let localAnalyser = null;
let remoteAnalyser = null;
let localMeterInterval = null;
let remoteMeterInterval = null;
let opAudioEl = null;

/* ---------------- UI refs ---------------- */
const roomsListEl = document.getElementById('roomsList');
const roomIdInput = document.getElementById('roomIdInput');
const createRoomBtn = document.getElementById('createRoomBtn');
const joinBtn = document.getElementById('joinBtn');
const leaveBtn = document.getElementById('leaveBtn');
const refreshRooms = document.getElementById('refreshRooms');
const playerNameInput = document.getElementById('playerName');
const micToggle = document.getElementById('micToggle');
const micStatus = document.getElementById('micStatus');
const statsEl = document.getElementById('stats');

const connStatus = document.getElementById('connStatus');
const myNameEl = document.getElementById('myName');
const opNameEl = document.getElementById('opName');
const myMarkEl = document.getElementById('myMark');
const opMarkEl = document.getElementById('opMark');
const mySpeaking = document.getElementById('mySpeaking');
const opSpeaking = document.getElementById('opSpeaking');
const myMeter = document.getElementById('myMeter');
const opMeter = document.getElementById('opMeter');

const boardEl = document.getElementById('board');
const turnInfo = document.getElementById('turnInfo');
const resultEl = document.getElementById('result');
const resetBtn = document.getElementById('resetBtn');

const chatLog = document.getElementById('chatLog');
const chatInput = document.getElementById('chatInput');
const sendChat = document.getElementById('sendChat');

/* ---------------- UI initialization ---------------- */
function initBoardUI(){
  boardEl.innerHTML = '';
  for(let i=0;i<9;i++){
    const c = document.createElement('div');
    c.className = 'cell';
    c.dataset.i = i;
    c.onclick = ()=> onCellClick(i);
    boardEl.appendChild(c);
  }
  renderBoard();
}
initBoardUI();

function renderBoard(){
  for(let i=0;i<9;i++){
    const c = boardEl.children[i];
    c.textContent = boardState[i] || '';
    c.classList.toggle('disabled', !myTurn || !!boardState[i]);
  }
  turnInfo.textContent = myTurn ? 'ã‚ãªãŸã®æ‰‹ç•ª (' + myMark + ')' : 'ç›¸æ‰‹ã®æ‰‹ç•ª (' + opMark + ')';
}

/* ---------------- Player ID & name ---------------- */
(function boot(){
  playerId = localStorage.getItem('webrtc_playerId');
  if(!playerId){ playerId = Math.random().toString(36).slice(2,9); localStorage.setItem('webrtc_playerId', playerId); }
  const storedName = localStorage.getItem('webrtc_playerName') || '';
  playerNameInput.value = storedName;
  ensurePlayerName();
  playerNameInput.addEventListener('change', ()=>{
    localStorage.setItem('webrtc_playerName', playerNameInput.value.trim());
    ensurePlayerName();
  });
})();

function ensurePlayerName(){
  playerName = (playerNameInput.value.trim() || ('Player-' + playerId.slice(0,4)));
  myNameEl.textContent = playerName;
  loadStats();
}

/* ---------------- Rooms listing & auto-match ---------------- */
async function fetchRooms(){
  roomsListEl.innerHTML = '<div style="color:var(--muted)">å–å¾—ä¸­â€¦</div>';
  const snap = await db.ref('rooms').orderByChild('createdAt').once('value');
  const data = snap.val() || {};
  roomsListEl.innerHTML = '';
  const rows = Object.entries(data).sort((a,b)=> (b[1].playersCount||0)-(a[1].playersCount||0));
  if(rows.length === 0){ roomsListEl.innerHTML = '<div style="color:var(--muted)">åˆ©ç”¨å¯èƒ½ãªãƒ«ãƒ¼ãƒ ãŒã‚ã‚Šã¾ã›ã‚“</div>'; return; }
  rows.forEach(([id, info])=>{
    const row = document.createElement('div');
    row.className = 'roomRow';
    row.innerHTML = `<div><strong>${id}</strong><div style="font-size:12px;color:var(--muted)">players: ${info.playersCount||0}</div></div>`;
    const btn = document.createElement('button');
    btn.className = 'small';
    btn.textContent = (info.playersCount||0) < 2 ? 'å‚åŠ ' : 'æº€å“¡';
    btn.disabled = (info.playersCount||0) >= 2;
    btn.onclick = ()=> { roomIdInput.value = id; joinToRoom(id); };
    row.appendChild(btn);
    roomsListEl.appendChild(row);
  });
}
refreshRooms.onclick = fetchRooms;
fetchRooms();

async function autoMatch(){
  const snap = await db.ref('rooms').once('value');
  const rooms = snap.val() || {};
  for(const id of Object.keys(rooms)){
    if((rooms[id].playersCount||0) < 2) return id;
  }
  return 'room-' + Math.random().toString(36).slice(2,8);
}

/* ---------------- Microphone / audio meters ---------------- */
micToggle.onclick = async ()=>{
  if(localStream){
    stopLocalAudio();
    return;
  }
  try{
    localStream = await navigator.mediaDevices.getUserMedia({ audio:true });
    micStatus.textContent = 'ãƒã‚¤ã‚¯: æ¥ç¶šä¸­';
    micToggle.textContent = 'ãƒã‚¤ã‚¯åœæ­¢';
    if(pc) attachLocalTracks();
    setupLocalMeter();
  }catch(e){
    console.error('mic err', e);
    alert('ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚æ¨©é™ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
  }
};
function stopLocalAudio(){
  if(!localStream) return;
  localStream.getTracks().forEach(t=>t.stop());
  localStream = null;
  micStatus.textContent = 'ãƒã‚¤ã‚¯: åœæ­¢';
  micToggle.textContent = 'ãƒã‚¤ã‚¯è¨±å¯ / åœæ­¢';
  if(localAnalyser){ localAnalyser.disconnect(); localAnalyser = null; }
  clearInterval(localMeterInterval);
  myMeter.style.width = '0%';
}
function setupLocalMeter(){
  try{
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const src = audioCtx.createMediaStreamSource(localStream);
    localAnalyser = audioCtx.createAnalyser();
    localAnalyser.fftSize = 256;
    src.connect(localAnalyser);
    localMeterInterval = setInterval(()=>{
      const arr = new Uint8Array(localAnalyser.frequencyBinCount);
      localAnalyser.getByteFrequencyData(arr);
      const sum = arr.reduce((a,b)=>a+b,0);
      const avg = sum / arr.length;
      const pct = Math.min(100, Math.round((avg/128)*100));
      myMeter.style.width = pct + '%';
      mySpeaking.textContent = pct > 12 ? 'ğŸŸ¢' : '';
      mySpeaking.className = pct > 12 ? 'speaking' : '';
    }, 150);
  }catch(e){ console.warn('local meter err', e); }
}

/* ---------------- WebRTC & signaling ---------------- */
async function preparePeerConnection(){
  pc = new RTCPeerConnection({ iceServers:[ { urls:'stun:stun.l.google.com:19302' } ] });

  // attach local audio tracks if present
  if(localStream){
    localStream.getAudioTracks().forEach(t => pc.addTrack(t, localStream));
  }

  // when remote track arrives
  remoteStream = new MediaStream();
  pc.ontrack = (ev)=> {
    ev.streams.forEach(s=> s.getAudioTracks().forEach(t => remoteStream.addTrack(t)));
    ensureRemoteAudioEl();
    opAudioEl.srcObject = remoteStream;
    opAudioEl.play().catch(()=>{});
    setupRemoteMeter();
  };

  // datachannel receive (joiner)
  pc.ondatachannel = (ev)=>{
    dc = ev.channel;
    setupDataChannel();
  };

  pc.onicecandidate = (e)=>{
    if(!e.candidate) return;
    if(!roomRef) return;
    const path = isHost ? 'offerCandidates' : 'answerCandidates';
    roomRef.child(path).push(e.candidate.toJSON());
  };

  pc.onconnectionstatechange = ()=> {
    connStatus.textContent = 'çŠ¶æ…‹: ' + pc.connectionState;
  };

  // if host, create datachannel
  if(isHost){
    dc = pc.createDataChannel('game');
    setupDataChannel();
  }
}

/* datachannel wiring */
function setupDataChannel(){
  if(!dc) return;
  dc.onopen = ()=> {
    console.log('DataChannel open');
    connStatus.textContent = 'DataChannel: open';
    // identity broadcast
    sendDC({ type:'identity', id:playerId, name:playerName });
    // host assigns marks and turn
    if(isHost){
      myMark = 'X';
      opMark = 'O';
      myMarkEl.textContent = myMark;
      opMarkEl.textContent = opMark;
      myTurn = true;
      renderBoard();
      // tell opponent their mark and that they are not first
      sendDC({ type:'assign', mark:'O', yourTurn:false });
    }
  };
  dc.onmessage = ev => {
    const data = safeJSON(ev.data);
    if(!data) return;
    handleAppMessage(data);
  };
  dc.onclose = ()=> console.log('dc closed');
}

/* safe JSON parse */
function safeJSON(s){
  try{ return JSON.parse(s); }catch(e){ return null; }
}

/* wrapper send */
function sendDC(obj){
  if(dc && dc.readyState === 'open') dc.send(JSON.stringify(obj));
}

/* create room (host) */
async function createRoomManual(id){
  ensurePlayerName();
  roomId = id || ('room-' + Math.random().toString(36).slice(2,8));
  isHost = true;
  roomRef = db.ref('rooms/' + roomId);
  // create entry with host as player
  await roomRef.set({ createdAt: Date.now(), playersCount: 1, players: { [playerId]: { name: playerName } } });
  // listen for answer and candidates
  await preparePeerConnection();

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  await roomRef.update({ offer: offer });

  roomRef.child('answer').on('value', async snap => {
    const val = snap.val();
    if(val && !pc.currentRemoteDescription){
      await pc.setRemoteDescription(new RTCSessionDescription(val));
      connStatus.textContent = 'çŠ¶æ…‹: answer å—ä¿¡';
    }
  });

  roomRef.child('answerCandidates').on('child_added', async s => {
    const cand = s.val();
    try{ await pc.addIceCandidate(new RTCIceCandidate(cand)); }catch(e){ console.warn(e); }
  });

  // observe players & chat
  roomRef.child('players').on('value', snap => updatePlayersUI(snap.val() || {}));
  roomRef.child('chat').on('child_added', snap => {
    const m = snap.val();
    appendChat(m.name, m.text, m.id === playerId ? 'self' : 'other');
  });

  // create offerCandidates listener (not strictly necessary but keep)
  roomRef.child('offerCandidates').on('child_added', snap => { /* host can ignore */ });

  connStatus.textContent = 'ãƒ«ãƒ¼ãƒ ä½œæˆ: ' + roomId;
  fetchRooms();
}

/* join flow */
async function joinToRoom(id){
  ensurePlayerName();
  roomId = id;
  roomRef = db.ref('rooms/' + roomId);
  const snap = await roomRef.once('value');
  if(!snap.exists()){ alert('éƒ¨å±‹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; }

  // add self to players and increment count
  await roomRef.child('players/' + playerId).set({ name: playerName });
  await roomRef.child('playersCount').transaction(c => (c||0) + 1);

  isHost = false;
  await preparePeerConnection();

  const offerSnap = await roomRef.child('offer').once('value');
  const offer = offerSnap.val();
  if(!offer){ alert('OfferãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; }
  await pc.setRemoteDescription(new RTCSessionDescription(offer));
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  await roomRef.update({ answer: answer });

  // handle incoming ICE candidates from host
  roomRef.child('offerCandidates').on('child_added', async s => {
    const cand = s.val();
    try{ await pc.addIceCandidate(new RTCIceCandidate(cand)); }catch(e){ console.warn(e); }
  });

  // send candidates are handled by pc.onicecandidate -> answerCandidates

  roomRef.child('players').on('value', snap => updatePlayersUI(snap.val() || {}));
  roomRef.child('chat').on('child_added', snap => {
    const m = snap.val();
    appendChat(m.name, m.text, m.id === playerId ? 'self' : 'other');
  });

  connStatus.textContent = 'ãƒ«ãƒ¼ãƒ å‚åŠ : ' + roomId;
  fetchRooms();
}

/* wait for DC open handled in setupDataChannel -> assign */
function handleAppMessage(data){
  switch(data.type){
    case 'identity':
      // show opponent name if not self
      if(data.id && data.id !== playerId){
        opNameEl.textContent = data.name || 'ç›¸æ‰‹';
        // also write into DB players map if missing
        if(roomRef) roomRef.child('players/' + data.id).once('value').then(snap=>{
          if(!snap.exists()) roomRef.child('players/' + data.id).set({ name: data.name || 'Player' });
        });
      }
      break;
    case 'assign':
      // joiner receives assign with mark and yourTurn flag
      opMark = (data.mark === 'X') ? 'X' : 'X'; // data.mark is opponent's mark for receiver
      myMark = data.mark;
      opMark = (myMark === 'X') ? 'O' : 'X';
      myMarkEl.textContent = myMark;
      opMarkEl.textContent = opMark;
      myTurn = !!data.yourTurn;
      renderBoard();
      break;
    case 'move':
      boardState[data.pos] = data.mark;
      // if opponent moved, it's your turn if game not ended
      myTurn = (data.mark !== myMark);
      renderBoard();
      checkGameEndAndNotify();
      break;
    case 'chat':
      appendChat(data.name || 'ç›¸æ‰‹', data.text, data.id === playerId ? 'self' : 'other');
      // persist chat in DB
      if(roomRef) roomRef.child('chat').push({ id: data.id, name: data.name, text: data.text, ts: Date.now() });
      break;
    case 'gameover':
      handleGameOver(data.winner);
      break;
    case 'reset':
      resetLocalBoard();
      break;
    default:
      console.log('unknown dc msg', data);
  }
}

/* ---------------- Game actions ---------------- */
function onCellClick(i){
  if(!dc || dc.readyState !== 'open'){ alert('ã¾ã æ¥ç¶šã•ã‚Œã¦ã„ã¾ã›ã‚“'); return; }
  if(!myTurn || boardState[i]) return;
  boardState[i] = myMark;
  renderBoard();
  sendDC({ type:'move', pos: i, mark: myMark });
  myTurn = false;
  checkGameEndAndNotify();
}

function checkGameEndAndNotify(){
  const winner = calcWinner(boardState);
  if(winner){
    sendDC({ type:'gameover', winner });
    handleGameOver(winner);
  } else if(boardState.every(Boolean)){
    sendDC({ type:'gameover', winner: 'draw' });
    handleGameOver('draw');
  }
}

function calcWinner(b){
  const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
  for(const [a,b1,c] of lines){
    if(b[a] && b[a] === b[b1] && b[a] === b[c]) return b[a];
  }
  return null;
}

async function handleGameOver(winner){
  if(winner === 'draw'){
    resultEl.textContent = 'å¼•ãåˆ†ã‘';
    await saveStats('draw');
  } else if(winner === myMark){
    resultEl.textContent = 'ã‚ãªãŸã®å‹ã¡';
    await saveStats('win');
  } else {
    resultEl.textContent = 'ç›¸æ‰‹ã®å‹ã¡';
    await saveStats('loss');
  }
}

/* reset */
resetBtn.onclick = ()=>{
  resetLocalBoard();
  sendDC({ type:'reset' });
};
function resetLocalBoard(){
  boardState = Array(9).fill(null);
  resultEl.textContent = '';
  myTurn = isHost; // host first
  renderBoard();
}

/* ---------------- Chat UI ---------------- */
function appendChat(name, text, cls='other'){
  const d = document.createElement('div');
  d.className = 'chatMsg ' + cls;
  d.textContent = name + ': ' + text;
  chatLog.appendChild(d);
  chatLog.scrollTop = chatLog.scrollHeight;
}
sendChat.onclick = ()=>{
  const txt = chatInput.value.trim();
  if(!txt) return;
  appendChat(playerName, txt, 'self');
  // send via DC and persist
  sendDC({ type:'chat', id: playerId, name: playerName, text: txt });
  if(roomRef) roomRef.child('chat').push({ id: playerId, name: playerName, text: txt, ts: Date.now() });
  chatInput.value = '';
};

/* ---------------- Players UI update ---------------- */
function updatePlayersUI(playersMap){
  const ids = Object.keys(playersMap || {});
  const otherId = ids.find(id => id !== playerId);
  myNameEl.textContent = playerName;
  if(otherId){
    opNameEl.textContent = playersMap[otherId].name || 'ç›¸æ‰‹';
  } else {
    opNameEl.textContent = '-';
  }
}

/* ---------------- Remote audio & meter ---------------- */
function ensureRemoteAudioEl(){
  if(opAudioEl) return;
  opAudioEl = document.createElement('audio');
  opAudioEl.autoplay = true;
  opAudioEl.style.display = 'none';
  document.body.appendChild(opAudioEl);
}

function setupRemoteMeter(){
  try{
    if(!opAudioEl || !opAudioEl.srcObject) return;
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const src = audioCtx.createMediaStreamSource(opAudioEl.srcObject);
    remoteAnalyser = audioCtx.createAnalyser();
    remoteAnalyser.fftSize = 256;
    src.connect(remoteAnalyser);
    remoteMeterInterval = setInterval(()=>{
      if(!remoteAnalyser) return;
      const arr = new Uint8Array(remoteAnalyser.frequencyBinCount);
      remoteAnalyser.getByteFrequencyData(arr);
      const sum = arr.reduce((a,b)=>a+b,0);
      const avg = sum / arr.length;
      const pct = Math.min(100, Math.round((avg/128)*100));
      opMeter.style.width = pct + '%';
      opSpeaking.textContent = pct > 12 ? 'ğŸŸ¢' : '';
      opSpeaking.className = pct > 12 ? 'speaking' : '';
    }, 180);
  }catch(e){ console.warn('remote meter err', e); }
}

/* attach local audio tracks to pc when available */
function attachLocalTracks(){
  if(!pc || !localStream) return;
  localStream.getAudioTracks().forEach(t => pc.addTrack(t, localStream));
}

/* ---------------- Stats persistence ---------------- */
async function loadStats(){
  ensurePlayerName();
  const snap = await db.ref('stats/' + playerId).once('value');
  const val = snap.val();
  if(val) stats = val;
  saveStatsToUI();
}
function saveStatsToUI(){
  statsEl.textContent = `Wins:${stats.wins||0} / Losses:${stats.losses||0} / Draws:${stats.draws||0}`;
}
async function saveStats(outcome){
  ensurePlayerName();
  if(outcome === 'win') stats.wins = (stats.wins||0) + 1;
  else if(outcome === 'loss') stats.losses = (stats.losses||0) + 1;
  else stats.draws = (stats.draws||0) + 1;
  await db.ref('stats/' + playerId).set({ name: playerName, ...stats });
  saveStatsToUI();
}

/* ---------------- Cleanup & leaving ---------------- */
leaveBtn.onclick = async ()=>{
  if(!roomRef) return;
  try{
    await roomRef.child('players/' + playerId).remove();
    await roomRef.child('playersCount').transaction(c => Math.max(0, (c||1) - 1));
    const snap = await roomRef.once('value');
    const val = snap.val() || {};
    if(!val.players || Object.keys(val.players).length === 0){
      await roomRef.remove();
    }
  }catch(e){ console.warn(e); }
  cleanupAll();
  fetchRooms();
};

function cleanupAll(){
  try{ if(dc){ dc.close(); dc=null; } }catch(e){}
  try{ if(pc){ pc.close(); pc=null; } }catch(e){}
  try{ if(roomRef){ roomRef.off(); roomRef=null; } }catch(e){}
  try{ if(localStream){ localStream.getTracks().forEach(t=>t.stop()); localStream=null; } }catch(e){}
  try{ if(opAudioEl){ opAudioEl.srcObject=null; opAudioEl.remove(); opAudioEl=null; } }catch(e){}
  myMark = opMark = '-';
  myMarkEl.textContent = myMark; opMarkEl.textContent = opMark;
  opNameEl.textContent = '-';
  boardState = Array(9).fill(null);
  myTurn = false;
  renderBoard();
  connStatus.textContent = 'çŠ¶æ…‹: åˆ‡æ–­';
}

/* ---------------- Utility ---------------- */
function ensurePlayerName(){ if(!playerNameInput.value.trim()){ playerName = 'Player-' + playerId.slice(0,4); } else playerName = playerNameInput.value.trim(); myNameEl.textContent = playerName; }

/* ---------------- UI Buttons wiring ---------------- */
createRoomBtn.onclick = async ()=> {
  ensurePlayerName();
  const id = roomIdInput.value.trim() || ('room-' + Math.random().toString(36).slice(2,7));
  await createRoomManual(id);
  fetchRooms();
};
joinBtn.onclick = async ()=> {
  ensurePlayerName();
  let id = roomIdInput.value.trim();
  if(!id) id = await autoMatch();
  await joinToRoom(id);
  fetchRooms();
};
document.getElementById('createRoomBtn').addEventListener('click', ()=>{}); // noop (already wired)
document.getElementById('refreshRooms').addEventListener('click', fetchRooms);

/* ---------------- Start: load stats initial ---------------- */
loadStats();

</script>
</body>
</html>
