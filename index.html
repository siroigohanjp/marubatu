<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ä¸‰ç›®ä¸¦ã¹</title>
<style>
  :root{ --bg:#0f1724; --panel:#0b1220; --card:#111827; --accent:#06b6d4; --good:#22c55e; --bad:#f87171; --muted:#94a3b8;}
  body{font-family:system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "ãƒ¡ã‚¤ãƒªã‚ª", sans-serif;background:var(--bg);color:#fff;padding:18px;box-sizing:border-box;}
  h1{margin:0 0 12px 0;font-size:20px}
  .row{display:flex;gap:8px;align-items:center;justify-content:center;margin-bottom:8px;flex-wrap:wrap}
  input,button{font-size:14px;padding:8px;border-radius:6px;border:0;outline:none}
  input{background:#081122;color:#fff}
  button{background:var(--card);color:#fff;cursor:pointer}
  #status{margin-top:8px;font-size:13px}
  #container{display:flex;gap:18px;flex-wrap:wrap;justify-content:center;margin-top:16px}
  #left, #right{width:360px;min-height:120px;background:var(--card);padding:12px;border-radius:8px}
  #board{display:grid;grid-template-columns:repeat(3,100px);gap:8px;justify-content:center;margin:10px auto}
  .cell{width:100px;height:100px;background:#0e1724;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:48px;cursor:pointer;transition:all .12s}
  .cell.disabled{opacity:.4;cursor:not-allowed}
  .win{background:var(--good)!important;box-shadow:0 0 18px rgba(34,197,94,.2)}
  .draw{opacity:.75}
  #turnInfo{margin-top:6px;font-weight:700}
  #turnInfo.active{color:var(--good);text-shadow:0 0 8px rgba(34,197,94,.12)}
  #chatLog{height:160px;overflow:auto;background:#071022;padding:8px;border-radius:6px;margin-bottom:8px}
  .chatMsg{font-size:13px;margin-bottom:6px}
  #roomList{max-height:200px;overflow:auto}
  .roomItem{display:flex;justify-content:space-between;padding:6px;border-radius:6px;background:#061322;margin-bottom:6px;cursor:pointer}
  .muted{color:var(--muted)}
  footer{margin-top:10px;font-size:12px;color:var(--muted);text-align:center}
</style>
<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-database-compat.js"></script>
</head>
<body>
<h1>ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ä¸‰ç›®ä¸¦ã¹ï¼ˆv0.20ï¼‰</h1>

<div class="row">
  <input id="playerName" placeholder="åå‰ã‚’å…¥åŠ›" />
  <input id="roomIdInput" placeholder="éƒ¨å±‹ã‚³ãƒ¼ãƒ‰" />
  <button id="createBtn">éƒ¨å±‹ã‚’ä½œã‚‹</button>
  <button id="joinBtn">å‚åŠ ã™ã‚‹</button>
  <button id="leaveBtn" style="display:none">é€€å‡º</button>
</div>
<div id="status">çŠ¶æ…‹: æœªæ¥ç¶š</div>

<div id="container">
  <div id="left">
    <div id="roomListTitle"><strong>ãƒ«ãƒ¼ãƒ ä¸€è¦§</strong></div>
    <div id="roomList" style="margin-top:8px"></div>
  </div>

  <div id="right">
    <div id="board"></div>
    <div id="turnInfo"></div>
    <div id="result" style="margin-top:6px"></div>
    <div style="margin-top:10px">
      <button id="rematchBtn" style="display:none">å†æˆ¦ãƒªã‚¯ã‚¨ã‚¹ãƒˆ</button>
    </div>

    <div style="margin-top:12px">
      <div><strong>ãƒãƒ£ãƒƒãƒˆ</strong></div>
      <div id="chatLog"></div>
      <div class="row" style="justify-content:center">
        <input id="chatInput" placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸" style="width:220px" disabled />
        <button id="chatSend" disabled>é€ä¿¡</button>
      </div>
    </div>
  </div>
</div>

<footer>Firebaseã§ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°ï¼ãƒãƒ£ãƒƒãƒˆï¼ˆãƒ«ãƒ¼ãƒ å˜ä½ï¼‰ã€‚3äººä»¥ä¸Šã¯å…¥ã‚Œã¾ã›ã‚“ã€‚</footer>

<script>
/* ===== Firebase è¨­å®š - å¿…è¦ãªã‚‰ç½®ãæ›ãˆã¦ãã ã•ã„ ===== */
  const firebaseConfig = {
    apiKey: "AIzaSyAI3pNSCaU2teHdqa1Rh1eLoQu1VZYtoh4",
    authDomain: "webrtc-gamesg.firebaseapp.com",
    databaseURL: "https://webrtc-gamesg-default-rtdb.firebaseio.com",
    projectId: "webrtc-gamesg",
    storageBucket: "webrtc-gamesg.firebasestorage.app",
    messagingSenderId: "214608437119",
    appId: "1:214608437119:web:369a938ed095dded62c44a"
  };
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ===== å¤‰æ•° ===== */
let pc, dc;
let isHost = false;
let myMark='-', opMark='-';
let myTurn = false;
let board = Array(9).fill(null);
let roomRef = null;
let chatRef = null;
let rematchRef = null;
let currentRoomId = null;
let gameOver = false;

/* ===== UI è¦ç´  ===== */
const playerNameInput = document.getElementById('playerName');
const roomIdInput = document.getElementById('roomIdInput');
const createBtn = document.getElementById('createBtn');
const joinBtn = document.getElementById('joinBtn');
const leaveBtn = document.getElementById('leaveBtn');
const statusEl = document.getElementById('status');
const roomListEl = document.getElementById('roomList');
const boardEl = document.getElementById('board');
const turnInfo = document.getElementById('turnInfo');
const resultEl = document.getElementById('result');
const chatLog = document.getElementById('chatLog');
const chatInput = document.getElementById('chatInput');
const chatSend = document.getElementById('chatSend');
const rematchBtn = document.getElementById('rematchBtn');

/* ===== ç›¤é¢ç”Ÿæˆ ===== */
for(let i=0;i<9;i++){
  const c = document.createElement('div');
  c.className='cell';
  c.dataset.i = i;
  c.onclick = ()=> handleCellClick(i);
  boardEl.appendChild(c);
}

/* ===== è¡¨ç¤ºæ›´æ–° ===== */
function render(){
  board.forEach((v,i)=>{
    const c = boardEl.children[i];
    c.textContent = v||'';
    c.classList.toggle('disabled', !myTurn || v || gameOver);
  });
  if(gameOver){
    turnInfo.textContent = 'ã‚²ãƒ¼ãƒ çµ‚äº†';
    turnInfo.classList.remove('active');
  } else {
    turnInfo.textContent = myTurn ? 'ã‚ãªãŸã®æ‰‹ç•ªï¼' : 'ç›¸æ‰‹ã®æ‰‹ç•ªâ€¦';
    turnInfo.classList.toggle('active', myTurn);
  }
}

/* ===== å‹æ•—åˆ¤å®š ===== */
function winCheck(){
  const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
  for(const [a,b,c] of lines){
    if(board[a] && board[a]==board[b] && board[a]==board[c]) return {winner: board[a], line:[a,b,c]};
  }
  if(board.every(Boolean)) return {winner:'draw'};
  return null;
}

/* ===== ãƒã‚¹ã‚¯ãƒªãƒƒã‚¯å‡¦ç† ===== */
function handleCellClick(i){
  if(!myTurn || board[i] || gameOver) return;
  board[i] = myMark;
  broadcast({type:'move', i});
  myTurn = false;
  render();
  const r = winCheck();
  if(r){
    gameOver = true;
    broadcast({type:'gameover', winner:r.winner, line:r.line});
    showResult(r.winner, r.line);
  }
}

/* ===== çµæœè¡¨ç¤º ===== */
function showResult(winner, line=[]){
  // clear previous highlights
  Array.from(boardEl.children).forEach(c=>{ c.classList.remove('win','draw'); });

  if(winner === 'draw'){
    resultEl.textContent = 'å¼•ãåˆ†ã‘ï¼';
    Array.from(boardEl.children).forEach(c=>c.classList.add('draw'));
    turnInfo.textContent = 'å¼•ãåˆ†ã‘ï¼';
    turnInfo.classList.add('drawText');
  } else {
    const isWin = (winner === myMark);
    resultEl.textContent = isWin ? 'ã‚ãªãŸã®å‹ã¡ï¼ğŸ‰' : 'ã‚ãªãŸã®è² ã‘â€¦ğŸ˜¢';
    turnInfo.textContent = isWin ? 'å‹åˆ©ï¼ğŸ‰' : 'æ•—åŒ—â€¦';
    if(line && line.length){
      line.forEach(i => boardEl.children[i].classList.add('win'));
    }
  }
  rematchBtn.style.display = 'inline-block';
  myTurn = false;
  render();
}

/* ===== Firebase: ãƒ«ãƒ¼ãƒ ä¸€è¦§ã®æ›´æ–° ===== */
function updateRoomList(){
  db.ref('rooms').on('value', snap=>{
    const data = snap.val() || {};
    roomListEl.innerHTML = '';
    Object.keys(data).forEach(rid=>{
      const room = data[rid];
      // remove empty rooms
      if(!room.host && !room.guest){
        db.ref('rooms/'+rid).remove();
        return;
      }
      const div = document.createElement('div');
      div.className = 'roomItem';
      div.innerHTML = `<span>${rid} (ãƒ›ã‚¹ãƒˆ: ${room.host || '-'})</span><span class="muted">${room.host && room.guest ? 'æº€' : 'å‚åŠ '}</span>`;
      div.onclick = () => {
        const name = playerNameInput.value.trim();
        if(!name){ alert('åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
        roomIdInput.value = rid;
        joinRoom(rid);
      };
      roomListEl.appendChild(div);
    });
  });
}
updateRoomList();

/* ===== ãƒãƒ£ãƒƒãƒˆã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ===== */
let chatListener = null;
function setupChat(roomId){
  chatLog.innerHTML = '';
  chatInput.disabled = false;
  chatSend.disabled = false;
  chatRef = db.ref(`rooms/${roomId}/chat`);
  // clear previous listeners
  chatRef.off();
  chatRef.on('child_added', snap=>{
    const v = snap.val();
    const d = document.createElement('div');
    d.className = 'chatMsg';
    d.innerHTML = `<b>${escapeHtml(v.name)}:</b> ${escapeHtml(v.msg)}`;
    chatLog.appendChild(d);
    chatLog.scrollTop = chatLog.scrollHeight;
  });
  chatSend.onclick = async ()=>{
    const txt = chatInput.value.trim();
    if(!txt || !chatRef) return;
    await chatRef.push({ name: playerNameInput.value.trim(), msg: txt, time: Date.now() });
    chatInput.value = '';
  };
}

/* ===== WebRTC ã‚·ã‚°ãƒŠãƒªãƒ³ã‚° via Firebase ===== */
async function createRoom(roomId){
  const name = playerNameInput.value.trim();
  if(!name){ alert('åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
  if(!roomId){ alert('éƒ¨å±‹ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }

  const rRef = db.ref('rooms/'+roomId);
  const s = await rRef.get();
  if(s.exists()){ alert('ã“ã®éƒ¨å±‹IDã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™ã€‚åˆ¥ã®IDã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚'); return; }

  isHost = true;
  currentRoomId = roomId;
  roomRef = rRef;
  await roomRef.set({ host: name, guest: null });

  // create RTCPeerConnection
  pc = new RTCPeerConnection({ iceServers: [{ urls:'stun:stun.l.google.com:19302' }] });
  dc = pc.createDataChannel('game');
  setupDataChannel();

  pc.onicecandidate = e => {
    if(e.candidate) roomRef.child('offerCandidates').push(e.candidate.toJSON());
  };
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  await roomRef.update({ offer });

  statusEl.textContent = `çŠ¶æ…‹: ä½œæˆæ¸ˆï¼ˆ${roomId}ï¼‰ - ç›¸æ‰‹ã‚’å¾…æ©Ÿä¸­...`;
  setupChat(roomId);
  setupRematch(roomId);
  leaveBtn.style.display = 'inline-block';

  // watch answer and candidate
  roomRef.on('value', async snap=>{
    const data = snap.val();
    if(!pc.currentRemoteDescription && data?.answer){
      await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
    }
  });
  roomRef.child('answerCandidates').on('child_added', async s=>{
    try{ await pc.addIceCandidate(new RTCIceCandidate(s.val())); }catch(e){}
  });
}

async function joinRoom(roomId){
  const name = playerNameInput.value.trim();
  if(!name){ alert('åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
  if(!roomId){ alert('éƒ¨å±‹ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }

  const rRef = db.ref('rooms/'+roomId);
  const s = await rRef.get();
  if(!s.exists()){ alert('éƒ¨å±‹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; }
  const data = s.val();

  if(data.host && data.guest){
    alert('ã“ã®éƒ¨å±‹ã¯ã™ã§ã«2äººãŒå‚åŠ ã—ã¦ã„ã¾ã™');
    return;
  }

  // mark guest
  await rRef.update({ guest: name });
  isHost = false;
  currentRoomId = roomId;
  roomRef = rRef;

  // create RTCPeerConnection and set remote offer
  pc = new RTCPeerConnection({ iceServers: [{ urls:'stun:stun.l.google.com:19302' }] });
  pc.ondatachannel = e => { dc = e.channel; setupDataChannel(); };
  pc.onicecandidate = e => { if(e.candidate) roomRef.child('answerCandidates').push(e.candidate.toJSON()); };

  await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  await roomRef.update({ answer });

  // assign marks: host X guest O  (host sets assign on open)
  // For guest we set local marks proactively:
  myMark = 'O'; opMark = 'X'; myTurn = false;
  render();

  statusEl.textContent = 'çŠ¶æ…‹: æ¥ç¶šä¸­...';
  setupChat(roomId);
  setupRematch(roomId);
  leaveBtn.style.display = 'inline-block';

  roomRef.child('offerCandidates').on('child_added', async s=>{
    try{ await pc.addIceCandidate(new RTCIceCandidate(s.val())); }catch(e){}
  });
}

/* ===== DataChannel ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ===== */
function setupDataChannel(){
  dc.onopen = () => {
    statusEl.textContent = 'çŠ¶æ…‹: æ¥ç¶šæ¸ˆã¿';
    if(isHost){
      myMark = 'X'; opMark = 'O'; myTurn = true;
      // let guest know assign
      sendLocal({ type:'assign', mark:'O', yourTurn:false });
    }
    render();
    chatInput.disabled = false;
    chatSend.disabled = false;
  };

  dc.onmessage = e => {
    const data = safeJsonParse(e.data);
    if(!data) return;
    if(data.type === 'move'){
      board[data.i] = data.mark;
      // opponent moved => our turn
      myTurn = true;
      render();
      const r = winCheck();
      if(r){
        gameOver = true;
        showResult(r.winner, r.line);
      }
    } else if(data.type === 'assign'){
      // assign message from host to guest
      myMark = data.mark;
      opMark = (data.mark === 'X' ? 'O' : 'X');
      myTurn = data.yourTurn || false;
      render();
    } else if(data.type === 'gameover'){
      gameOver = true;
      showResult(data.winner, data.line);
    } else if(data.type === 'guestLeft'){
      // host receives guestLeft: reset board/chat but keep host name and room
      if(isHost){
        board = Array(9).fill(null);
        gameOver = false;
        myTurn = true; // host is first
        Array.from(boardEl.children).forEach(c=>{ c.textContent=''; c.classList.remove('win','draw','disabled'); });
        chatLog.innerHTML = '';
        turnInfo.textContent = 'ç›¸æ‰‹ãŒé€€å‡ºã—ã¾ã—ãŸã€‚å¾…æ©Ÿä¸­...';
        statusEl.textContent = `çŠ¶æ…‹: å¾…æ©Ÿä¸­ï¼ˆ${currentRoomId}ï¼‰`;
        chatInput.disabled = true; chatSend.disabled = true;
        rematchBtn.style.display = 'none';
      }
    } else if(data.type === 'hostLeft'){
      // guest receives hostLeft: room removed (host left)
      // reset UI fully (names cleared)
      alert('ãƒ›ã‚¹ãƒˆãŒé€€å‡ºã—ã¾ã—ãŸã€‚éƒ¨å±‹ã¯é–‰ã˜ã‚‰ã‚Œã¾ã—ãŸã€‚');
      fullReset(true);
    } else if(data.type === 'rematchRequest'){
      // other side requested rematch -> show accept button
      if(!gameOver) return;
      if(confirm('ç›¸æ‰‹ãŒå†æˆ¦ã‚’å¸Œæœ›ã—ã¦ã„ã¾ã™ã€‚å†æˆ¦ã‚’é–‹å§‹ã—ã¾ã™ã‹ï¼Ÿ')){
        requestRematchAccept();
      }
    }
  };
}

/* helper to send through both datachannel and firebase fallback */
function broadcast(obj){
  // send via datachannel if present
  try{
    sendLocal(obj);
  }catch(e){}
  // also optionally send via firebase if desired (not necessary)
}
function sendLocal(obj){
  if(dc && dc.readyState === 'open'){
    dc.send(JSON.stringify(obj));
  }
}

/* ===== å†æˆ¦ (ç°¡æ˜“) ===== */
function setupRematch(roomId){
  rematchRef = db.ref('rooms/'+roomId+'/rematch');
  rematchRef.remove();
  rematchRef.on('value', snap=>{
    const v = snap.val() || {};
    if(v.hostReady && v.guestReady){
      // start rematch
      board = Array(9).fill(null);
      gameOver = false;
      myTurn = isHost; // host first
      Array.from(boardEl.children).forEach(c=>{ c.textContent=''; c.classList.remove('win','draw','disabled'); });
      resultEl.textContent = '';
      rematchRef.remove();
      rematchBtn.style.display = 'none';
      render();
    }
  });
}
rematchBtn.onclick = ()=>{
  if(!rematchRef) return;
  rematchBtn.disabled = true;
  rematchBtn.textContent = 'ç›¸æ‰‹ã®æº–å‚™ã‚’å¾…ã£ã¦ã„ã¾ã™...';
  rematchRef.update(isHost ? { hostReady:true } : { guestReady:true });
};
function requestRematchAccept(){
  // the other side already set both flags via UI -> handled by rematchRef listener
  // do nothing here; UI will start rematch when both flags present
}

/* ===== é€€å‡ºå‡¦ç†ï¼ˆè¦ä»¶ã«åˆã‚ã›ãŸæŒ™å‹•ï¼‰ ===== */
leaveBtn.onclick = ()=> {
  if(!currentRoomId) { fullReset(false); return; }
  leaveRoom(currentRoomId);
};

async function leaveRoom(roomId){
  if(!roomRef) return;
  const name = playerNameInput.value.trim();
  if(isHost){
    // ãƒ›ã‚¹ãƒˆãŒé€€å‡º -> éƒ¨å±‹ã”ã¨å‰Šé™¤ã€‚ãƒãƒ£ãƒƒãƒˆã‚‚å‰Šé™¤
    if(chatRef) await chatRef.remove();
    await roomRef.remove();
    // notify guest via datachannel if open
    try{ sendLocal({ type:'hostLeft' }); }catch(e){}
    fullReset(true); // clear everything incl. name
    statusEl.textContent = 'çŠ¶æ…‹: æœªæ¥ç¶šï¼ˆéƒ¨å±‹ã‚’é–‰ã˜ã¾ã—ãŸï¼‰';
    currentRoomId = null;
  } else {
    // ã‚²ã‚¹ãƒˆãŒé€€å‡º -> guest ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å‰Šé™¤ã€‚ãƒãƒ£ãƒƒãƒˆå±¥æ­´ã‚’å‰Šé™¤ã€‚
    await roomRef.update({ guest: null });
    if(chatRef) await chatRef.remove();
    // notify host via datachannel
    try{ sendLocal({ type:'guestLeft' }); }catch(e){}
    // guest side: reset UI but keep guest name? requirement: "ã‚²ã‚¹ãƒˆãŒé€€å‡ºã‚’æŠ¼ã—ãŸã‚‰ã‚²ã‚¹ãƒˆãŒã‚ã‚åå‰ä»¥å¤–å…¨éƒ¨åˆæœŸåŒ–ãƒ›ã‚¹ãƒˆã¯åå‰ã‚’æ®‹ã—ã¦éƒ¨å±‹ã‹ã‚‰å‡ºãªã„ã§åˆæœŸåŒ–"
    // So guest (this client) should clear everything except their own name? earlier asked guest name cleared? User requested: "ã‚²ã‚¹ãƒˆãŒé€€å‡ºã‚’æŠ¼ã—ãŸã‚‰ã‚²ã‚¹ãƒˆãŒã‚ã‚åå‰ä»¥å¤–å…¨éƒ¨åˆæœŸåŒ–ãƒ›ã‚¹ãƒˆã¯åå‰ã‚’æ®‹ã—ã¦éƒ¨å±‹ã‹ã‚‰å‡ºãªã„ã§åˆæœŸåŒ–"
    // Implement guest: reset everything except keep player's name input value intact (so they can rejoin)
    resetLocalUIKeepName();
    statusEl.textContent = 'çŠ¶æ…‹: æœªæ¥ç¶šï¼ˆé€€å‡ºã—ã¾ã—ãŸï¼‰';
    currentRoomId = null;
  }
}

/* ===== UI ãƒªã‚»ãƒƒãƒˆé–¢æ•° ===== */
function fullReset(clearName = false){
  board = Array(9).fill(null);
  myMark = opMark = '-';
  myTurn = false;
  gameOver = false;
  roomRef = null;
  chatRef = null;
  rematchRef = null;
  currentRoomId = null;
  pc = null; dc = null;
  Array.from(boardEl.children).forEach(c=>{ c.textContent=''; c.classList.remove('win','draw','disabled'); });
  chatLog.innerHTML = '';
  resultEl.textContent = '';
  turnInfo.textContent = '';
  rematchBtn.style.display = 'none';
  leaveBtn.style.display = 'none';
  chatInput.disabled = true; chatSend.disabled = true;
  if(clearName) playerNameInput.value = '';
}

/* Guest-side reset that keeps the player's name field value */
function resetLocalUIKeepName(){
  const keepName = playerNameInput.value.trim();
  fullReset(true); // clear names
  if(keepName) playerNameInput.value = keepName; // restore guest's name only
}

/* ===== Helpers ===== */
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, ch=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'})[ch]);}
function safeJsonParse(s){ try{ return JSON.parse(s); }catch(e){return null;} }

/* ===== ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ: create/join (UIãƒã‚§ãƒƒã‚¯ã‚ã‚Š) ===== */
createBtn.onclick = () => {
  const name = playerNameInput.value.trim();
  const rid = roomIdInput.value.trim();
  if(!name){ alert('åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
  if(!rid){ alert('éƒ¨å±‹ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
  createRoom(rid);
};
joinBtn.onclick = () => {
  const name = playerNameInput.value.trim();
  const rid = roomIdInput.value.trim();
  if(!name){ alert('åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
  if(!rid){ alert('éƒ¨å±‹ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
  joinRoom(rid);
};

/* ===== createRoom wrapper that uses full WebRTC signaling (like earlier) ===== */
async function createRoom(roomId){
  const name = playerNameInput.value.trim();
  if(!name) { alert('åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
  roomRef = db.ref('rooms/'+roomId);
  const s = await roomRef.get();
  if(s.exists()){ alert('ã“ã®éƒ¨å±‹IDã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™ã€‚'); return; }
  isHost = true;
  currentRoomId = roomId;
  await roomRef.set({ host: name, guest: null });
  // make PC and create offer
  pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
  dc = pc.createDataChannel('game');
  setupDataChannel();
  pc.onicecandidate = e => { if(e.candidate) roomRef.child('offerCandidates').push(e.candidate.toJSON()); };
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  await roomRef.update({ offer });
  statusEl.textContent = `çŠ¶æ…‹: ä½œæˆæ¸ˆï¼ˆ${roomId}ï¼‰ - ç›¸æ‰‹ã‚’å¾…æ©Ÿä¸­...`;
  setupChat(roomId);
  setupRematch(roomId);
  leaveBtn.style.display = 'inline-block';
  roomRef.on('value', async snap=>{
    const data = snap.val();
    if(!pc.currentRemoteDescription && data?.answer){
      await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
    }
  });
  roomRef.child('answerCandidates').on('child_added', async s=>{
    try{ await pc.addIceCandidate(new RTCIceCandidate(s.val())); }catch(e){}
  });
}

/* joinRoom wrapper that uses full WebRTC signaling (like earlier) */
async function joinRoom(roomId){
  const name = playerNameInput.value.trim();
  if(!name) { alert('åå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
  roomRef = db.ref('rooms/'+roomId);
  const s = await roomRef.get();
  if(!s.exists()){ alert('éƒ¨å±‹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; }
  const data = s.val();
  if(data.host && data.guest){ alert('ã“ã®éƒ¨å±‹ã¯ã™ã§ã«2äººãŒå‚åŠ ã—ã¦ã„ã¾ã™'); return; }
  await roomRef.update({ guest: name });
  isHost = false;
  currentRoomId = roomId;
  pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
  pc.ondatachannel = e => { dc = e.channel; setupDataChannel(); };
  pc.onicecandidate = e => { if(e.candidate) roomRef.child('answerCandidates').push(e.candidate.toJSON()); };
  await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  await roomRef.update({ answer });
  // guest initial marks
  myMark = 'O'; opMark = 'X'; myTurn = false;
  render();
  statusEl.textContent = 'çŠ¶æ…‹: æ¥ç¶šä¸­...';
  setupChat(roomId);
  setupRematch(roomId);
  leaveBtn.style.display = 'inline-block';
  roomRef.child('offerCandidates').on('child_added', async s=>{
    try{ await pc.addIceCandidate(new RTCIceCandidate(s.val())); }catch(e){}
  });
}

/* åˆæœŸUI */
render();
statusEl.textContent = 'çŠ¶æ…‹: æœªæ¥ç¶š';
</script>
</body>
</html>
